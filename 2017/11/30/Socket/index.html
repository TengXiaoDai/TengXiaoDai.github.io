<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="python,编程," />










<meta name="description" content="socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过”套接字”向网络发出请求或者应答网络请求。 socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭） s">
<meta name="keywords" content="python,编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Python Socket">
<meta property="og:url" content="https://zt-blog.club/2017/11/30/Socket/index.html">
<meta property="og:site_name" content="张腾">
<meta property="og:description" content="socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过”套接字”向网络发出请求或者应答网络请求。 socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭） s">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p086obi9v.bkt.clouddn.com/tcp.jpg.bmp">
<meta property="og:image" content="http://p086obi9v.bkt.clouddn.com/mwfxmlzu.bmp">
<meta property="og:updated_time" content="2018-01-17T03:20:32.126Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python Socket">
<meta name="twitter:description" content="socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过”套接字”向网络发出请求或者应答网络请求。 socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭） s">
<meta name="twitter:image" content="http://p086obi9v.bkt.clouddn.com/tcp.jpg.bmp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zt-blog.club/2017/11/30/Socket/"/>





  <title>Python Socket | 张腾</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
	<a href="https://github.com/TengXiaoDai"><img style="position: absolute; top: 0; left: 0; border: 0;" src="http://p086obi9v.bkt.clouddn.com/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>
	</div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张腾</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zt-blog.club/2017/11/30/Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangTeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张腾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python Socket</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T17:09:44+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p>
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）</p>
<p>socket和file的区别：</p>
<pre><code>file模块是针对某个指定文件进行【打开】【读写】【关闭】
socket模块是针对 服务器端 和 客户端Socket 进行【打开】【读写】【关闭】
</code></pre><p><img src="http://p086obi9v.bkt.clouddn.com/tcp.jpg.bmp" alt="avatar"></p>
<p>Socket Server       </p>
<pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-

import socket
ip_port = (&apos;127.0.0.1&apos;,9999)

sk = socket.socket()
sk.bind(ip_port)
sk.listen(5)

while True:
   print &apos;server waiting...&apos;
   conn,addr = sk.accept()

client_data = conn.recv(1024)
print client_data
conn.sendall(&apos;不要回答,不要回答,不要回答&apos;)
conn.close()        
</code></pre><p>Socket Client       </p>
<pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
import socket
ip_port = (&apos;127.0.0.1&apos;,9999)
sk = socket.socket()
sk.connect(ip_port)
sk.sendall(&apos;请求占领地球&apos;)
server_reply = sk.recv(1024)
print server_reply
sk.close()
</code></pre><p>WEB服务应用：       </p>
<pre><code> #!/usr/bin/env python
 #coding:utf-8
 import socket

 def handle_request(client):
     buf = client.recv(1024)
     client.send(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)
     client.send(&quot;Hello, World&quot;)

def main():
   sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   sock.bind((&apos;localhost&apos;,8080))
   sock.listen(5)

 while True:
    connection, address = sock.accept()
    handle_request(connection)
    connection.close()

if __name__ == &apos;__main__&apos;:
     main()      
</code></pre><p>**更多功能<br>sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)<br>参数一：地址簇<br>　　  socket.AF_INET IPv4（默认）<br>　  　socket.AF_INET6 IPv6<br>　　  socket.AF_UNIX 只能够用于单一的Unix系统进程间通信</p>
<p>参数二：类型            </p>
<p>　　socket.SOCK_STREAM　　流式socket , for TCP （默认）<br>　　socket.SOCK_DGRAM　　 数据报式socket , for UDP<br>　　socket.SOCK_RAW 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。<br>　　socket.SOCK_RDM 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。<br>　　socket.SOCK_SEQPACKET 可靠的连续数据包服务</p>
<p>参数三：协议</p>
<p>　　0　　（默认）与特定的地址家族相关的协议,如果是 0 ，则系统就会根据地址格式和套接类别,自动选择一个合适的协议<br>　　<br>UDP-Demo        </p>
<pre><code>    import socket
    ip_port = (&apos;127.0.0.1&apos;,9999)
    sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0)
    sk.bind(ip_port)

    while True:
      data = sk.recv(1024)
      print data




   import socket
   ip_port = (&apos;127.0.0.1&apos;,9999)

   sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0)
   while True:
     inp = raw_input(&apos;数据：&apos;).strip()
     if inp == &apos;exit&apos;:
        break
   sk.sendto(inp,ip_port)

sk.close()      
</code></pre><p>sk.bind(address)<br>　　s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。</p>
<p>sk.listen(backlog)</p>
<p>　　开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。</p>
<pre><code>backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5
这个值不能无限大，因为要在内核中维护连接队列
</code></pre><p>sk.setblocking(bool)</p>
<p>　　是否阻塞（默认True），如果设置False，那么accept和recv时一旦无数据，则报错。</p>
<p>sk.accept()</p>
<p>　　接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。</p>
<p>　　接收TCP 客户的连接（阻塞式）等待连接的到来</p>
<p>sk.connect(address)</p>
<p>　　连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。</p>
<p>sk.connect_ex(address)</p>
<p>　　同上，只不过会有返回值，连接成功时返回 0 ，连接失败时候返回编码，例如：10061</p>
<p>sk.close()</p>
<p>　　关闭套接字</p>
<p>sk.recv(bufsize[,flag])</p>
<p>　　接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。</p>
<p>sk.recvfrom(bufsize[.flag])</p>
<p>　　与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</p>
<p>sk.send(string[,flag])</p>
<p>　　将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。</p>
<p>sk.sendall(string[,flag])</p>
<p>　　将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</p>
<pre><code>内部通过递归调用send，将所有内容发送出去。
</code></pre><p>sk.sendto(string[,flag],address)</p>
<p>　　将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。</p>
<p>sk.settimeout(timeout)</p>
<p>　　设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）</p>
<p>sk.getpeername()</p>
<p>　　返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</p>
<p>sk.getsockname()</p>
<p>　　返回套接字自己的地址。通常是一个元组(ipaddr,port)</p>
<p>sk.fileno()</p>
<p>　　套接字的文件描述符          
　　        </p>
<pre><code>    # 服务端
   import socket
   ip_port = (&apos;127.0.0.1&apos;,9999)
   sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0)
   sk.bind(ip_port)

  while True:
   data,(host,port) = sk.recvfrom(1024)
   print(data,host,port)
   sk.sendto(bytes(&apos;ok&apos;, encoding=&apos;utf-8&apos;), (host,port))


  #客户端
  import socket
  ip_port = (&apos;127.0.0.1&apos;,9999)

  sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,0)
  while True:
    inp = input(&apos;数据：&apos;).strip()
    if inp == &apos;exit&apos;:
       break
 sk.sendto(bytes(inp, encoding=&apos;utf-8&apos;),ip_port)
 data = sk.recvfrom(1024)
 print(data)
sk.close()　　 
</code></pre><p> 实例：智能机器人       </p>
<pre><code>   服务端:     
   #!/usr/bin/env python
   # -*- coding:utf-8 -*-
   import socket
   ip_port = (&apos;127.0.0.1&apos;,8888)
   sk = socket.socket()
   sk.bind(ip_port)
   sk.listen(5)

  while True:
     conn,address =  sk.accept()
     conn.sendall(&apos;欢迎致电 10086，请输入1xxx,0转人工服务.&apos;)
     Flag = True
    while Flag:
       data = conn.recv(1024)
       if data == &apos;exit&apos;:
           Flag = False
       elif data == &apos;0&apos;:
          conn.sendall(&apos;通过可能会被录音.balabala一大推&apos;)
       else:
          conn.sendall(&apos;请重新输入.&apos;)
   conn.close()        

   客服端:     
   #!/usr/bin/env python
   # -*- coding:utf-8 -*-

   import socket
   ip_port = (&apos;127.0.0.1&apos;,8005)
   sk = socket.socket()
   sk.connect(ip_port)
   sk.settimeout(5)

   while True:
      data = sk.recv(1024)
      print &apos;receive:&apos;,data
      inp = raw_input(&apos;please input:&apos;)
      sk.sendall(inp)
     if inp == &apos;exit&apos;:
          break
sk.close()     
</code></pre><p>//利用Python SocketServer来处理并发     </p>
<pre><code>二、socket server           
</code></pre><p>SocketServer内部使用 IO多路复用 以及 “多线程” 和 “多进程” ，从而实现并发处理多个客户端请求的Socket服务端。即：每个客户端请求连接到服务器时，Socket服务端都会在服务器是创建一个“线程”或者“进 程” 专门负责处理当前客户端的所有请求。<br><strong>注：导入模块的时候 3.x版本是socketserver 2.x版本是SocketServer</strong><br><img src="http://p086obi9v.bkt.clouddn.com/mwfxmlzu.bmp" alt=""></p>
<p>1.ThreadingTCPServer</p>
<p>ThreadingTCPServer实现的Soket服务器内部会为每个client创建一个 “线程”，该线程用来和客户端进行交互。</p>
<pre><code>ThreadingTCPServer基础
使用ThreadingTCPServer:
</code></pre><p>创建一个继承自 SocketServer.BaseRequestHandler 的类<br>类中必须定义一个名称为 handle 的方法<br>启动ThreadingTCPServer          </p>
<pre><code>    **服务端**      
    import SocketServer
    MyServer(SocketServer.BaseRequestHandler):
         def handle(self):
            conn = self.request
            conn.sendall(&apos;我是多线程&apos;)
            Flag = True
            while Flag:
                data = conn.recv(1024)
                if data == &apos;exit&apos;:
                     Flag = False
                elif data == &apos;0&apos;:
                     conn.sendall(&apos;您输入的是0&apos;)
                else:
                     conn.sendall(&apos;请重新输入.&apos;)
   if __name__ == &apos;__main__&apos;:
         server = SocketServer.ThreadingTCPServer((&apos;127.0.0.1&apos;,8009),MyServer)
         server.serve_forever()     


**客服端**      
#!/usr/bin/env python
# -*- coding:utf-8 -*-
import socket
ip_port = (&apos;127.0.0.1&apos;,8009)
sk = socket.socket()
sk.connect(ip_port)
while True:
   data = sk.recv(1024)
   print &apos;receive:&apos;,data
   inp = input(&apos;please input:&apos;)
   sk.sendall(inp)
   if inp == &apos;exit&apos;:
        break
sk.close()
</code></pre><p><strong>内部调用流程为：</strong>        </p>
<pre><code>1.启动服务端程序
2.执行 TCPServer.init 方法，创建服务端Socket对象并绑定 IP 和 端口
3.执行 BaseServer.init 方法，将自定义的继承自SocketServer.BaseRequestHandler 的类 - MyRequestHandle赋值给 self.RequestHandlerClass
4.执行 BaseServer.server_forever 方法，While 循环一直监听是否有客户端请求到达 ...
当客户端连接到达服务器
5.执行 ThreadingMixIn.process_request 方法，创建一个 “线程” 用来处理请求
6.执行 ThreadingMixIn.process_request_thread 方法
7.执行 BaseServer.finish_request 方法，执行 self.RequestHandlerClass() 即：执行 自定义 MyRequestHandler 的构造方法（自动调用基类BaseRequestHandler的构造方法，在该构造方法中又会调用 MyRequestHandler的handle方法）       
</code></pre><p>ForkingTCPServer</p>
<p>ForkingTCPServer和ThreadingTCPServer的使用和执行流程基本一致，只不过在内部分别为请求者建立 “线程” 和 “进程”。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    ZhangTeng
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zt-blog.club/2017/11/30/Socket/" title="Python Socket">https://zt-blog.club/2017/11/30/Socket/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://zt-blog.club" rel="external nofollow" target="_blank">Zhangteng</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
            <a href="/tags/编程/" rel="tag"># 编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/23/Decorator/" rel="next" title="Python装饰器与AOP">
                <i class="fa fa-chevron-left"></i> Python装饰器与AOP
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/01/ioMultiplexing/" rel="prev" title="Python IO复用与多线程">
                Python IO复用与多线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ZhangTeng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangTeng</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://github.com/TengXiaoDai">TengXiaoDai</a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
